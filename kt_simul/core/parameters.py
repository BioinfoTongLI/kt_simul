# -*- coding: utf-8 -*-
"""
Module dealing with simulation parameters
"""

from __future__ import unicode_literals
from __future__ import division
from __future__ import absolute_import
from __future__ import print_function

import logging
import os

import pandas as pd

# Those strings should be respected in the xml file
SPRING_UNIT = u'pN/µm'
DRAG_UNIT = u'pN.s/µm'
LENGTH_UNIT = u'µm'
FREQ_UNIT = u'Hz'
FORCE_UNIT = u'pN'
SPEED_UNIT = u'µm/s'

CURRENT_DIR = os.path.abspath(os.path.dirname(__file__))
ROOT_DIR = os.path.dirname(CURRENT_DIR)
PARAMFILE = os.path.join(ROOT_DIR, 'io', 'params.json')
MEASUREFILE = os.path.join(ROOT_DIR, 'io', 'measures.json')

log = logging.getLogger(__name__)


def adimentionalize(data, metadata):
    """This function scales everything taking dt as unit time, Vk as
    unit speed, and Fk as unit force. It relies on a correct
    definition of the units of the elements of the param tree,
    thus a correct spelling in the json file, so please beware.
    """
    Vk = data["Vk"]
    Fk = data["Fk"]
    dt = data["dt"]

    for name, values in metadata.iterrows():
        value = data[name]

        if values['unit'] == SPRING_UNIT:
            value /= Fk
        elif values['unit'] == DRAG_UNIT:
            value *= Vk / Fk
        elif values['unit'] == SPEED_UNIT:
            value /= Vk
        elif values['unit'] == FREQ_UNIT:
            value *= dt
        elif values['unit'] == FORCE_UNIT:
            value /= Fk

        data[name] = value


def get_default_params():
    """
    """
    return pd.read_json(PARAMFILE).set_index('name')


def get_default_measures():
    """
    """
    return pd.read_json(MEASUREFILE).set_index('name')


def reduce_params(params, measures, force_parameters=[]):
    """
    This functions changes the parameters so that
    the dynamical characteristics complies with the measures [1]_.

    Parameters
    ----------

    paramtree :
        Modified in place.
    measuretree :

    References
    ----------
    .. [1] G. Gay, T.Courthéoux, C. Reyes, S. Tournier, Y. Gachet.
           J. Cell Biol 2012 http://dx.doi.org/10.1083/jcb.201107124

    """

    try:
        poleward_speed = measures['poleward_speed']
        metaph_rate = measures['metaph_rate']
        anaph_rate = measures['anaph_rate']
        mean_metaph_k_dist = measures['mean_metaph_k_dist']
        max_metaph_k_dist = measures['max_metaph_k_dist']
        outer_inner_dist = measures['oi_dist']
        tau_k = measures['tau_k']
        tau_c = measures['tau_c']
        obs_d0 = measures['obs_d0']
        mean_kt_spb_dist = measures["mean_kt_spb_dist"]

        k_d0 = params['k_d0']
        k_a = params['k_a']
        d_alpha = params['d_alpha']
        N = int(params['N'])
        Mk = int(params['Mk'])
        mus = params['mus']
        Fk = params['Fk']

    except KeyError:
        log.warning("Some parametree / measuretree values are missing")
        return False

    # Set various parameters from measures
    if 'd0' not in force_parameters:
        params['d0'] = obs_d0
    d0 = params['d0']

    if 'ldep_balance' not in force_parameters:
        params['ldep_balance'] = mean_kt_spb_dist

    # Set max speed from measures
    if 'Vk' not in force_parameters:
        params['Vk'] = poleward_speed
    Vk = params['Vk']

    if 'Vmz' not in force_parameters:
        params['Vmz'] = anaph_rate
    Vmz = params['Vmz']

    # Set spring constant from measures
    if 'kappa_c' not in force_parameters:
        params['kappa_c'] = Fk * Mk * 2 / (max_metaph_k_dist - d0)
    kappa_c = params['kappa_c']

    if 'kappa_k' not in force_parameters:
        params['kappa_k'] = Fk * Mk * 2 / (2 * outer_inner_dist)
    kappa_k = params['kappa_k']

    # Set drag coefficient from measure
    if 'muc' not in force_parameters:
        muc = (tau_c * kappa_c)
        params['muc'] = muc

    if 'muk' not in force_parameters:
        muk = (tau_k * kappa_k)
        params['muk'] = muk

    if 'k_d0' not in force_parameters:
        params['k_d0'] = k_a

    # Get "average" constant of simulation

    # Get mean detachment rate (depend on Aurora parameter)
    if d_alpha != 0:
        # Inverse distribution
        prefactor = d_alpha / (mean_metaph_k_dist / 2)

        k_d_eff = k_d0 * prefactor
    else:
        k_d_eff = k_d0

    # Get mean attachment rate
    k_a_eff = k_a

    # Compute mean attachment state during a simulation
    alpha_mean = 1 / (1 + k_d_eff / k_a_eff)

    # Compute max force generated by spindle midzone motor
    if 'Fmz' not in force_parameters:
        Fmz = (Fk * N * Mk * alpha_mean * (1 + metaph_rate / (2 * Vk)) + mus * metaph_rate / 2.)
        Fmz /= (1 - metaph_rate / Vmz)
        params['Fmz'] = Fmz
